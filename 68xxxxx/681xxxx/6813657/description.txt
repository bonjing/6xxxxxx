The proliferation of processors, environments, and constraints on systems has cast compiler technology into a wider variety of settings, changing the compiler and compiler writer's role. No longer is execution speed the sole criterion for judging compiled code. Today, code might be judged on how small it is, how much power it consumes, how well it compresses, or how many page faults it generates. In this evolving environment, the task of building a successful compiler relies upon the compiler writer's ability to balance and blend algorithms, engineering insights, and careful planning. Today's compiler writer must choose a path through a design space that is filled with diverse alternatives, each with distinct costs, advantages, and complexities.

Engineering a Compiler explores this design space by presenting some of the ways these problems have been solved, and the constraints that made each of those solutions attractive. By understanding the parameters of the problem and their impact on compiler design, the authors hope to convey both the depth of the problems and the breadth of possible solutions. Their goal is to cover a broad enough selection of material to show readers that real tradeoffs exist, and that the impact of those choices can be both subtle and far-reaching.

Authors Keith Cooper and Linda Torczon convey both the art and the science of compiler construction and show best practice algorithms for the major passes of a compiler. Their text re-balances the curriculum for an introductory course in compiler construction to reflect the issues that arise in current practice.

Â·Focuses on the back end of the compiler-reflecting the focus of research and development over the last decade.
Â·Uses the well-developed theory from scanning and parsing to introduce concepts that play a critical role in optimization and code generation.
Â·Introduces the student to optimization through data-flow analysis, SSA form, and a selection of scalar optimizations.
Â·Builds on this background to teach modern methods in code generation: instruction selection, instruction scheduling, and register allocation.
Â·Presents examples in several different programming languages in order to best illustrate the concept. 


# Hardcover: 824 pages
# Publisher: Morgan Kaufmann; 2 edition (February 21, 2011)
# Language: English
# ISBN-10: 012088478X
# ISBN-13: 978-0120884780